# Spring Security Architecture
## What is Spring Security?
- It helps `protect APIs, web apps, and microservices` from unauthorized access, attacks and security threats.

## What is Authentication? (ðŸ”‘ Identity Verification)
- `Authentication` is the process of verifying `who you are`.
- It ensures that the user is `legitimate` before granting access. Means the user is valid or not

## What is Authorization? (ðŸšª Access Control)
- `Authorization` determines `what you can do` after authentication.
- It ensures `users only access what they are allowed to`.

## Add spring security:
- `Step1`: Add spring-boot-starter-security
```xml
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
  </dependency> 
</dependencies>
```
- `Step2`: Run the spring boot project. Check the console you will find a security password. It will be changed everytime I run the application
```
Using generated security password: .........
```
- After this we can hit the endpoint mentioned in the `controller` and put the `username: user` and `password: ..........`

## Architecture
- `Filter` is a big part in `spring security`. In `filter` there is something called `Filter chain` which is a `chain of filters`. `Filters` are part of `Servlet API` which have `seperate lifecyle` appart from the `spring application`
![image](https://github.com/user-attachments/assets/6b9d3ed4-4137-4a7c-bc7f-6fce246f4483)
- When we add the `spring security dependency` in pom then a chain called `SecurityFilterChain` is added in the list of filter
![image](https://github.com/user-attachments/assets/07f2255a-ebe1-424d-b8da-f4888c31671e)

## DelegatingFilterProxy
- Let assume we have `servlet API lifecycle`. It has a `seperate lifecycle` from my `Spring application`
- So, we have `servlet API` and `Spring application` both are different and we are `intrigetting` both.
- Filter is a part of `Servlet`. So, for that reason `filter` has not any access on `Beans` in `Spring application`.
- For that reason we want a `bridze` between them, to connect `servlet api` with `spring application`. Here the **DelegatingFilterProxy** comes.
![image](https://github.com/user-attachments/assets/9d807896-1d72-4b0d-8a55-ba1a24d43ad4)

### Defination
Spring provides a `filter` implementation named **DelegatingFilterProxy** that allows `bridging` between the Servlet container's lifecycle and Spring ApplicationContext. The `Servlet container` allows registering `Filter` instances by using there `own standards`, but it is not aware of `Spring-defined beans`. You can register `DelegatingFilterProxy` through the `Standard Servlet Container mechanisms` but delegate all the work to a Spring Bean that implements `Filter`
![image](https://github.com/user-attachments/assets/d9dc5613-66d4-4031-8d6b-2ab275b30549)
![image](https://github.com/user-attachments/assets/53d5d817-6396-4ae6-8889-41acf886c833)

## FilterChainProxy
It is a specual proxy which is added in `DelegatingFilterProxy` which has the `SecurityFilterChain` and inside `SecurityFilterChain` there are many filters
![image](https://github.com/user-attachments/assets/a32fe105-33b7-49d4-99e5-da3ce09106e0)

## What happened after the security added
- A default username and password is generated by the spring
- But when we use that inside the productions then we should use the username and password which we stored inside our DB
- Or we can use OAuth2 for Authentication
- We have also JWT authentication
- We have LDAP authentication

![image](https://github.com/user-attachments/assets/40402b23-994e-4de1-8afb-c6e5ae4f154a)

## Filter Chain
![image](https://github.com/user-attachments/assets/aedfb522-c046-4a04-9b24-5d3654201608)
- Loging username and password needs `form based authentication` for that we have `UsernamePasswordAuthenticationFilter` will be used

![image](https://github.com/user-attachments/assets/c7d7969b-09d9-469d-8453-0b1a26411af6)

- All the method of doing authentication is `not added` inside the `filter`. To handle each type of `authentication`, spring provide its own `Authentication Provider`. Example for username and password we have `DAOAuthenticationProvider`, for OAuth2 we have `OAuth2LoginAuthenticationProvider`. Spring segrigate the `Authentication` from the `Filter`
- When the request is come to `UsernameAndPasswordAuthenticationFilter` it will delegate the request to the respective `Authentication Provider` which will authenticate the request for us.

![image](https://github.com/user-attachments/assets/e9b784b0-95ba-48e3-8d3a-852ad0a25385)

- Now how spring boot will know which Authentication Provider is used for which filter. For solving this issue spring has `Authentication manager` it will bridze the gap between `Filters` and `Authentication Provider`. When the request come to `Filter`, filter will pass that to the `Authentication manager` and in authentication manager has `Provider Manager` (is the impementation of the `Authentication manager`), it will `iterate` through each of the `Authentication Provider` and check which will support the `incomeing request`. `Authentication Provider` has a `supports()` methods which will return if the `provider` support the incomeing request or not. If support then it will delegate the request to the `Authentication Provider`
![image](https://github.com/user-attachments/assets/8f0b2711-2e32-4ef5-b952-7b8d996479c1)

## How the Authentication Provider will evaluate the Username and password:
- If the username and password is present in the database then to authenticate that spring provide us with something called `UserDetailsService`
- So, the `Authentication provider` will connect with the `UserDetailsService`
- The `UserDetailsService` has intefaces, if we storing inside in memory then we have `InMemoryUserDetailsManager`, otherwise we have `JDBCUserDetailsManager` which will connect to the database and fetch the user information and return it to the `UserDetailsService` and then it will return it to the `Authentication Provider`
- Here `UserDetailsService` is a interface provided by the `spring security`

![image](https://github.com/user-attachments/assets/4677da9c-00af-49f8-bd5e-ae4970319d34)

- Before saving the password in the database we `encode` it. So, when the encoded password is come to `Authentication Provider` then it need to `decode` the password before check it because the user try to login with the acutal password not the encoded one. So for that `Authentication Provider` has `Password Encoder` which encode and decode the password 

![image](https://github.com/user-attachments/assets/b46d5852-f9e9-4e52-b431-46ac64cc8bdb)

- After Authentication Done the `Authentication provider` will return the `Object of Authentication` and then it will be return by the `Authentication Manager` to `Filter`.
- So, after that is `Object` need to store somewhere so that other part of the spring application will be `access` it to check all the details of the authentication.
- So for that spring has something called `SecurityContext`. So the `authentication object/ principal object` will be stored inside it.
- Inorder to access in the spring boot application spring has provided abstraction which is called `SecurityContextHolder` which has method called `getContext()` which will return the object
![image](https://github.com/user-attachments/assets/fbe139ba-7a56-434b-9aa5-325911f9176b)

- If I try to load the loged in url again and again it will not asked for me to logged in, but if i changed the session then I need to login
- So handle it spring has `SecurityContextHolderFilter`, it will remenber the authenticated request so in loading for the same session it don't ask for login

![image](https://github.com/user-attachments/assets/865b4786-1f46-4755-97e9-c1b4b03c5d9c)

- If I provided a wrong password of configuration then that exception is handled by a filter called `ExceptionTranslationFilter` and it will throw the error (401, 403) to client.
![image](https://github.com/user-attachments/assets/e1624cf7-cdf6-4ad1-a7d9-da0a8ed86b66)


  





