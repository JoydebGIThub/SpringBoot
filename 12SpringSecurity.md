# Spring Security Architecture
## What is Spring Security?
- It helps `protect APIs, web apps, and microservices` from unauthorized access, attacks and security threats.

## What is Authentication? (ðŸ”‘ Identity Verification)
- `Authentication` is the process of verifying `who you are`.
- It ensures that the user is `legitimate` before granting access. Means the user is valid or not

## What is Authorization? (ðŸšª Access Control)
- `Authorization` determines `what you can do` after authentication.
- It ensures `users only access what they are allowed to`.

## Add spring security:
- `Step1`: Add spring-boot-starter-security
```xml
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
  </dependency> 
</dependencies>
```
- `Step2`: Run the spring boot project. Check the console you will find a security password. It will be changed everytime I run the application
```
Using generated security password: .........
```
- After this we can hit the endpoint mentioned in the `controller` and put the `username: user` and `password: ..........`

## Architecture
- `Filter` is a big part in `spring security`. In `filter` there is something called `Filter chain` which is a `chain of filters`. `Filters` are part of `Servlet API` which have `seperate lifecyle` appart from the `spring application`
![image](https://github.com/user-attachments/assets/6b9d3ed4-4137-4a7c-bc7f-6fce246f4483)
- When we add the `spring security dependency` in pom then a chain called `SecurityFilterChain` is added in the list of filter
![image](https://github.com/user-attachments/assets/07f2255a-ebe1-424d-b8da-f4888c31671e)

## DelegatingFilterProxy
- Let assume we have `servlet API lifecycle`. It has a `seperate lifecycle` from my `Spring application`
- So, we have `servlet API` and `Spring application` both are different and we are `intrigetting` both.
- Filter is a part of `Servlet`. So, for that reason `filter` has not any access on `Beans` in `Spring application`.
- For that reason we want a `bridze` between them, to connect `servlet api` with `spring application`. Here the **DelegatingFilterProxy** comes.
![image](https://github.com/user-attachments/assets/9d807896-1d72-4b0d-8a55-ba1a24d43ad4)

### Defination
Spring provides a `filter` implementation named **DelegatingFilterProxy** that allows `bridging` between the Servlet container's lifecycle and Spring ApplicationContext. The `Servlet container` allows registering `Filter` instances by using there `own standards`, but it is not aware of `Spring-defined beans`. You can register `DelegatingFilterProxy` through the `Standard Servlet Container mechanisms` but delegate all the work to a Spring Bean that implements `Filter`
![image](https://github.com/user-attachments/assets/d9dc5613-66d4-4031-8d6b-2ab275b30549)
![image](https://github.com/user-attachments/assets/53d5d817-6396-4ae6-8889-41acf886c833)

## FilterChainProxy
It is a specual proxy which is added in `DelegatingFilterProxy` which has the `SecurityFilterChain` and inside `SecurityFilterChain` there are many filters
![image](https://github.com/user-attachments/assets/a32fe105-33b7-49d4-99e5-da3ce09106e0)

## What happened after the security added
- A default username and password is generated by the spring
- But when we use that inside the productions then we should use the username and password which we stored inside our DB
- Or we can use OAuth2 for Authentication
- We have also JWT authentication
- We have LDAP authentication

![image](https://github.com/user-attachments/assets/40402b23-994e-4de1-8afb-c6e5ae4f154a)

## Filter Chain
![image](https://github.com/user-attachments/assets/aedfb522-c046-4a04-9b24-5d3654201608)
- Loging username and password needs `form based authentication` for that we have `UsernamePasswordAuthenticationFilter` will be used

![image](https://github.com/user-attachments/assets/c7d7969b-09d9-469d-8453-0b1a26411af6)

- All the method of doing authentication is `not added` inside the `filter`. To handle each type of `authentication`, spring provide its own `Authentication Provider`. Example for username and password we have `DAOAuthenticationProvider`, for OAuth2 we have `OAuth2LoginAuthenticationProvider`. Spring segrigate the `Authentication` from the `Filter`
- When the request is come to `UsernameAndPasswordAuthenticationFilter` it will delegate the request to the respective `Authentication Provider` which will authenticate the request for us.

![image](https://github.com/user-attachments/assets/e9b784b0-95ba-48e3-8d3a-852ad0a25385)

- Now how spring boot will know which Authentication Provider is used for which filter. For solving this issue spring has `Authentication manager` it will bridze the gap between `Filters` and `Authentication Provider`. When the request come to `Filter`, filter will pass that to the `Authentication manager` and in authentication manager has `Provider Manager` (is the impementation of the `Authentication manager`), it will `iterate` through each of the `Authentication Provider` and check which will support the `incomeing request`. `Authentication Provider` has a `supports()` methods which will return if the `provider` support the incomeing request or not. If support then it will delegate the request to the `Authentication Provider`
![image](https://github.com/user-attachments/assets/8f0b2711-2e32-4ef5-b952-7b8d996479c1)

## How the Authentication Provider will evaluate the Username and password:
- If the username and password is present in the database then to authenticate that spring provide us with something called `UserDetailsService`
- So, the `Authentication provider` will connect with the `UserDetailsService`
- The `UserDetailsService` has intefaces, if we storing inside in memory then we have `InMemoryUserDetailsManager`, otherwise we have `JDBCUserDetailsManager` which will connect to the database and fetch the user information and return it to the `UserDetailsService` and then it will return it to the `Authentication Provider`
- Here `UserDetailsService` is a interface provided by the `spring security`

![image](https://github.com/user-attachments/assets/4677da9c-00af-49f8-bd5e-ae4970319d34)

- Before saving the password in the database we `encode` it. So, when the encoded password is come to `Authentication Provider` then it need to `decode` the password before check it because the user try to login with the acutal password not the encoded one. So for that `Authentication Provider` has `Password Encoder` which encode and decode the password 

![image](https://github.com/user-attachments/assets/b46d5852-f9e9-4e52-b431-46ac64cc8bdb)

- After Authentication Done the `Authentication provider` will return the `Object of Authentication` and then it will be return by the `Authentication Manager` to `Filter`.
- So, after that is `Object` need to store somewhere so that other part of the spring application will be `access` it to check all the details of the authentication.
- So for that spring has something called `SecurityContext`. So the `authentication object/ principal object` will be stored inside it.
- Inorder to access in the spring boot application spring has provided abstraction which is called `SecurityContextHolder` which has method called `getContext()` which will return the object
![image](https://github.com/user-attachments/assets/fbe139ba-7a56-434b-9aa5-325911f9176b)

- If I try to load the loged in url again and again it will not asked for me to logged in, but if i changed the session then I need to login
- So handle it spring has `SecurityContextHolderFilter`, it will remenber the authenticated request so in loading for the same session it don't ask for login

![image](https://github.com/user-attachments/assets/865b4786-1f46-4755-97e9-c1b4b03c5d9c)

- If I provided a wrong password of configuration then that exception is handled by a filter called `ExceptionTranslationFilter` and it will throw the error (401, 403) to client.
![image](https://github.com/user-attachments/assets/e1624cf7-cdf6-4ad1-a7d9-da0a8ed86b66)

-----------------------------------------------------------------------------------------------------------------------
# Spring Security Basic Authentication
- When we add the security to the spring application and hit the url it redirect to a `Login form` so we can say its a `form based authentication`
- So if my application is totally backend and i don't have any frontend then I don't want the `formbasedauthentication`.
- So, inorder to do that we want the `Basic Authentication`
- If the user request is unauthendicated then then It will catch by the `ExceptionTranslationFilter` and send to the user
![image](https://github.com/user-attachments/assets/95315b58-0d92-4ade-865c-ad6e24e9e250)

- So, In `SecurityFilterChain` we have added `BasicAuthenticationFilter` and it will generate `UsernamePasswordAuthenticationToken` and it will pass the token to `AuthenticationManager` if it success then we stored it inside `SecurityContextHolder` and we let the user continue with the application else we store failor to the `SecurityContextHolder`.
![image](https://github.com/user-attachments/assets/089a9f63-1887-45e6-b460-fd72159eea9a)

- When we add the `spring-boot-starter-security` dependency then spring by default enable `FormBasedAuthentication` and the default filter is `UsernamePasswordAuthenticationFilter`, so we need to tell the spring to use `Basic Authentication filter` instade of `UsernamePasswordAuthenticationFilter`.
- So, to do that we need to add `explecite bean for every things`.
- Now add a `SecurityConfig` class and add the `@Configuration` to make the class `Configuration class` then add `@EnableWebSecurity` it will tells the spring security application, that we are enable the security features inside the spring boot application. For basic authentication we need to create a filter chain

![image](https://github.com/user-attachments/assets/56c1e866-84aa-42dc-b6a7-06628060e383)

- Now we also can add our own username and password in application.properties

```properties
spring.security.user.name=admin
spring.security.user.password=admin123
```
- Untill we add the `@Bean` over the securityfilterchain method it will show us the `form based authentication` when we hit the url

![image](https://github.com/user-attachments/assets/ea65f70a-1c8c-4f29-bcab-28d30a64093e)

- After this when we hit the url it will directly login without asking for username and password.
- So, for enable the authentication in `basic authentication` we need to tell the `http.httpBasic(withDefaults())` which url I want to `authenticated`.
- So, we add a lambda function in `authorizeHttpRequests()` method so that each request is authenticated

![image](https://github.com/user-attachments/assets/b1b47ad2-818d-4531-bb16-c33a0d5fd863)
![image](https://github.com/user-attachments/assets/7537c1f4-8c14-4561-a3ae-14b54219521b)

- Now we want to fecth the username and password from DB so we need an entity class 
![image](https://github.com/user-attachments/assets/6485d72e-386f-41fa-9665-a6a57ea7c14e)

- After entity we need a repository interface
![image](https://github.com/user-attachments/assets/c74644de-02c0-47f0-8ef1-ea5e606e76c0)

- So, now we need to create a custom `UserDetailsService` and tell the `Authentication provider` to use it and that `Authentication Prodiver` we need to set inside the `Authentication Manager` also we need the `Password Encoder`
- So, we create a `CustomeUserDetailsService` and implements `UserDetailsService` and `Override` the `loadUserByUsername()` method

![image](https://github.com/user-attachments/assets/ff4ba703-3ef9-4be6-9938-377a099c4fd8)
 
- now inject the `repository` but the method returns UserDetails but our reporsitory give the User

![image](https://github.com/user-attachments/assets/e516e309-afe8-4625-bbed-726b80008471)

- To solve the issue we need to implements the `UserDetails` in the entity class and `override` all the implemented method

![image](https://github.com/user-attachments/assets/4aea7eed-6fee-452b-a13f-5e5395314a7c)

- So the implemented methods are `isAccoundNonExpried()` return true because an expried account cannot be authenticated
- then comes `isAccontNonLock()` return ture because locked user cannot be authenticated

![image](https://github.com/user-attachments/assets/1c26171d-7c14-4f28-870a-e2c882bda764)

- And there are 2 more methods `isCredentailsNonExpired() and isEnable` are both return true

![image](https://github.com/user-attachments/assets/a9ceaab5-6d8b-4be5-8b58-17ebd3907210)
  
- So, we have another method `getAuthorities()` it will returns the authories granted to the user. Cannot return null. Its used for authorization purpose. Spring uses `GrantedAuthority` to take `authority` decession so we need to convert the role and pass it to the `SimpleGrantedAuthority()`

![image](https://github.com/user-attachments/assets/9f0c071c-7e81-4999-afd3-6cf7059db856)

- Now the error in the `CustomUserDetailsService` error is gone

![image](https://github.com/user-attachments/assets/5546cb48-719b-4f85-8c07-68f18b89e017)

- So, in configuration class we add a new method called `authenticationManager()` and create instance of `DaoAuthenticationProvider`, now `setUserDetailsService()`

![image](https://github.com/user-attachments/assets/0f64f3d6-d66b-4680-8a46-f4486f26a7ab)

- Now we need to tell the `authentication provider` which `password encoder` it needs to use

![image](https://github.com/user-attachments/assets/06e1ea61-f581-4daa-9f88-121313c597d7)

- Now we need to return the `ProviderManager`

![image](https://github.com/user-attachments/assets/a75a4eca-3297-4260-874f-178aae7e1974)

- 









   





